<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>K·∫æT QU·∫¢ KI·ªÇM TRA OQC - v4 (Reference)</title>
  <style>
    /* Common styles */
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f5f7fa; }
    .container { padding: 20px; }
    .tab-buttons { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap:wrap; }
    .tab-buttons button {
      padding: 10px 20px; border: none; border-radius: 6px;
      background: #34495e; color: #fff; cursor: pointer;
    }
    .tab-buttons button.active { background: #27ae60; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    /* Tab 1: Ph√°n ƒë·ªãnh s·∫£n ph·∫©m */
    .app-container { display: flex; flex-direction: row; gap:20px; }
    .left, .right { padding: 20px; overflow-y: auto; background: #fff; border-radius:8px; box-shadow: 0 1px 3px rgba(0,0,0,0.06); }
    .left { width: 40%; border-right: none; }
    .right { width: 60%; }
    label { font-weight: bold; display: block; margin: 10px 0 5px; }
    input, select { padding: 5px; width: 200px; margin-bottom: 10px; border-radius:4px; border:1px solid #ccc; }
    button { padding: 8px 16px; margin: 6px; border-radius: 6px; border: 1px solid #333; font-size: 14px; cursor: pointer; }
    #okBtn { color: green; }
    #ngBtn { color: red; }
    #error { color: red; font-weight: bold; margin-top: 10px; }
    table { margin-top: 10px; border-collapse: collapse; width: 100%; background: #fff; }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: center; }
    th { background: #eee; }
    .duplicate { background-color: #ffb3b3; }
    #loginScreen { margin-top: 20px; text-align: center; }
    .mainApp { display: none; }
    #clearLogBtn, #resetDataBtn { position: absolute; top: 12px; padding: 6px 12px; border: none; border-radius: 6px; cursor: pointer; }
    #clearLogBtn { right: 120px; background: #3498db; color: white; }
    #clearLogBtn:hover { background: #2980b9; }
    #resetDataBtn { right: 12px; background: #e74c3c; color: white; }
    #resetDataBtn:hover { background: #c0392b; }
    .stat { margin-top: 8px; font-size: 14px; }
    .small { font-size:13px; color:#666; }

    /* Tab 2 / reference */
    .ref-status { margin-bottom:8px; font-weight:bold; }

    /* Misc */
    .sync-status {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      display: none;
    }
    .sync-success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .sync-error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .app-container { flex-direction: column; }
      .left, .right { width: 100%; }
    }

    /* Filter styles for Tab 3 */
    .filter-container { display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; }
    .filter-item { display: flex; flex-direction: column; }
    .filter-item label { font-size: 12px; margin-bottom: 4px; }
    .button-container { display: flex; gap: 10px; margin-bottom: 15px; }
    .btn-filter, .btn-download, .btn-reset { 
      padding: 8px 16px; 
      color: white; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
    }
    .btn-filter { background: #3498db; }
    .btn-download { background: #27ae60; }
    .btn-reset { background: #e74c3c; }
    .btn-reset:hover { background: #c0392b; }

    /* Sync button styles */
    .sync-btn {
      position: relative;
      padding: 10px 18px;
      font-size: 16px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s, transform 0.2s;
    }
    .sync-btn:hover { background: #2980b9; }
    .sync-btn:disabled {
      background: #95a5a6;
      cursor: not-allowed;
    }
    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.4);
      border-left-color: white;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      animation: spin 0.8s linear infinite;
      display: inline-block;
      vertical-align: middle;
      margin-right: 8px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/clusterize.js@0.18.1/clusterize.min.js"></script>
</head>
<body>
   <div style="margin-top:20px; display:flex; gap:10px; ">
      <img src="logo.png" alt="Logo" style="height: 100px; width: auto; margin-right: 20px;">
      <h2>üìä K·∫æT QU·∫¢ KI·ªÇM TRA OQC</h2>
      </div>
     </div>
    
    <div class="tab-buttons">
      <button id="btnTab1" class="active" onclick="showTab(1)">üìù Ph√°n ƒë·ªãnh s·∫£n ph·∫©m</button>
      <button id="btnTab2" onclick="showTab(2)">üßæ D·ªØ li·ªáu PRO (TEST)</button>
      <button id="btnTab3" onclick="showTab(3)">üîß PQC</button>
      <button id="btnTab4" onclick="showTab(4)">üìë D·ªØ li·ªáu QC (OQC)</button>
      <button id="btnTab5" onclick="showTab(5)">üìà Bi·ªÉu ƒë·ªì</button>
    </div>
    
    <!-- Tab 1: Ph√°n ƒë·ªãnh s·∫£n ph·∫©m -->
    <div id="tab1" class="tab-content active">
      <!-- M√†n h√¨nh ƒëƒÉng nh·∫≠p -->
      <div id="loginScreen">
        <h2>ƒêƒÉng nh·∫≠p</h2>
        <label for="loginUser">T√™n ƒëƒÉng nh·∫≠p</label>
        <input type="text" id="loginUser" placeholder="Nh·∫≠p m√£ s·ªë nh√¢n vi√™n">
        <label for="loginPass">M·∫≠t kh·∫©u</label>
        <input type="password" id="loginPass" placeholder="Nh·∫≠p m·∫≠t kh·∫©u">
        <label for="shift">Ch·ªçn ca</label>
        <select id="shift">
          <option value="Ca 1 (06:00-14:00)">Ca 1 (06:00 - 14:00)</option>
          <option value="Ca 2 (14:00-22:00)">Ca 2 (14:00 - 22:00)</option>
          <option value="Ca 1 d√†i (06:00-18:00)">Ca 1 d√†i (06:00 - 18:00)</option>
          <option value="Ca 2 d√†i (18:00-06:00)">Ca 2 d√†i (18:00 - 06:00 h√¥m sau)</option>
          <option value="Ca HC (08:00-16:30)">Ca HC (08:00 - 16:30)</option>
        </select>
        <label for="wo">S·ªë l·ªánh s·∫£n xu·∫•t (WO)</label>
        <input type="text" id="wo" placeholder="Nh·∫≠p s·ªë WO" oninput="this.value=this.value.toUpperCase()">
        <br>
        <button onclick="login()">ƒêƒÉng nh·∫≠p</button>
        <p id="loginError" style="color:red;"></p>
      </div>

      <!-- Giao di·ªán ch√≠nh -->
      <div id="mainApp" class="mainApp app-container" style="display:none;">
        <!-- C·ªôt tr√°i -->
        <div class="left">
          <h2>Ph√°n ƒë·ªãnh s·∫£n ph·∫©m</h2>
          <div style="position:relative;">
            <button id="clearLogBtn" onclick="clearLogDisplay()">X√≥a log</button>
            <button id="resetDataBtn" onclick="resetAllData()">Reset d·ªØ li·ªáu</button>
          </div>

          <p class="stat">üë§ Ng∆∞·ªùi ki·ªÉm tra: <b id="currentUser"></b></p>
          <p class="stat">üïí Ca: <b id="currentShift"></b></p>
          <p class="stat">üìã WO: <b id="currentWO"></b></p>
          <p class="stat">‚úÖ OK: <b id="okCount">0</b> | ‚ùå NG: <b id="ngCount">0</b></p>

          <label for="deliveryQty"><b>S·ªê L∆Ø·ª¢NG GIAO</b></label>
          <input type="number" id="deliveryQty" value="0" min="0" style="width:150px;">
          <p id="deliveryStatus" style="color:blue;font-weight:bold;"></p>

          <label for="mahang">M√£ h√†ng</label>
          <select id="mahang">
            <option value="">-- Ch·ªçn m√£ h√†ng --</option>
            <option value="ECM-2583-236">ECM-2583-236</option>
            <option value="ECM-2583-164">ECM-2583-164</option>
            <option value="ECM-2300">ECM-2300</option>
            <option value="ECM-2310">ECM-2310</option>
            <option value="IZ-1-R3">IZ-1-R3</option>
            <option value="RM-4K-R3">RM-4K-R3</option>
            <option value="P-7937">P-7937</option>
            <option value="P-8105">P-8105</option>
            <option value="P-8149">P-8149</option>
            <option value="BMS 85AH">BMS 85AH</option>
            <option value="BMS 57AH">BMS 57AH</option>
            <option value="CONTROLLER">CONTROLLER</option>
            <option value="CAS NEMO">CAS NEMO</option>
            <option value="CAS MINI-DI">CAS MINI-DI</option>
            <option value="CAS MINI-485">CAS MINI-485</option>
            <option value="BN 2573A">BN 2573A</option>
            <option value="OEM">OEM</option>
            <option value="CONTROLLER (RETURN)">CONTROLLER (RETURN)</option>
            <option value="BMS 85AH (RETURN)">BMS 85AH (RETURN)</option>
            <option value="BMS 57AH (RETURN)">BMS 57AH (RETURN)</option>
          </select>

          <label for="qrcode">QR Code</label>
          <div style="display: flex; align-items: center; gap: 10px;">
            <input type="text" id="qrcode" placeholder="Qu√©t QR code" oninput="this.value=this.value.toUpperCase(); checkQRStatus(this.value);">
            <span id="qrStatus" style="font-weight: bold; min-width: 200px;"></span>
          </div>
          <div class="small"><span id="qrSource" class="small"></span></div>

          <label for="loi">L·ªói / Ghi ch√∫</label>
          <div style="display: flex; gap: 10px;">
            <input list="errorList" id="loi" placeholder="Nh·∫≠p l·ªói (n·∫øu c√≥)">
            <input type="text" id="ghichu" placeholder="Nh·∫≠p ghi ch√∫ (n·∫øu c√≥)">
          </div>
          <datalist id="errorList">
            <option value="H√†n gi·∫£">H√†n gi·∫£</option>
            <option value="Sai Linh Ki·ªán">Sai Linh Ki·ªán</option>
            <option value="L·ªói PCB">L·ªói PCB</option>
            <option value="L·ªèng Ng√†m Connector">L·ªèng Ng√†m Connector</option>
            <option value="Tr√†n Thi·∫øc Tr·ªü Shunt">Tr√†n Thi·∫øc Tr·ªü Shunt</option>
            <option value="L·ªói mosfet">L·ªói mosfet</option>
            <option value="L·ªách Linh ki·ªán">L·ªách Linh ki·ªán</option>
            <option value="B·∫Øc C·∫ßu">B·∫Øc C·∫ßu</option>
            <option value="M·∫•t Linh Ki·ªán">M·∫•t Linh Ki·ªán</option>
            <option value="M·ªëi h√†n">M·ªëi h√†n</option>
            <option value="L·ªói ·ªëc">L·ªói ·ªëc</option>
            <option value="L·ªói n·∫πp vi·ªÅn">L·ªói n·∫πp vi·ªÅn</option>
            <option value="Thi·∫øu Potting">Thi·∫øu Potting</option>
            <option value="L·ªói 3M">L·ªói 3M</option>
            <option value="L·ªói form U">L·ªói form U</option>
            <option value="Thi·∫øu Coating">Thi·∫øu Coating</option>
            <option value="Tr√†n Coating">Tr√†n Coating</option>
            <option value="V·ªá sinh">V·ªá sinh</option>
            <option value="B·ªã thi·∫øc">B·ªã thi·∫øc</option>
            <option value="L·ªói chi·ªÅu cao tr·ªü">L·ªói chi·ªÅu cao tr·ªü</option>
            <option value="Ch√°y gai ·ªëc">Ch√°y gai ·ªëc</option>
            <option value="L·ªói b·ªçc co nhi·ªát">L·ªói b·ªçc co nhi·ªát</option>
            <option value="L·ªói d√¢y √¢m">L·ªói d√¢y √¢m</option>
            <option value="L·ªói tem pass">L·ªói tem pass</option>
            <option value="Tr√≥c pad">Tr√≥c pad</option>
            <option value="Cao led">Cao led</option>
            <option value="H∆∞ linh ki·ªán">H∆∞ linh ki·ªán</option>
            <option value="K√™nh linh ki·ªán">K√™nh linh ki·ªán</option>
            <option value="Nghi√™ng led">Nghi√™ng led</option>
            <option value="Thi·∫øu thi·∫øc">Thi·∫øu thi·∫øc</option>
            <option value="Ph·∫ø/Scrap">Ph·∫ø/Scrap</option>
            <option value="Test Fail">Test Fail</option>
            <option value="Ch∆∞a Test">Ch∆∞a Test</option>
          </datalist>

          <div>
            <button id="okBtn" onclick="saveData('OK')">OK</button>
            <button id="ngBtn" onclick="saveData('NG')">NG</button>
          </div>
        
          <p id="error"></p>

          <!-- Th√™m th√¥ng b√°o tr·∫°ng th√°i ƒë·ªìng b·ªô -->
          <div id="syncStatus" class="sync-status"></div>

          <div>
            <button onclick="exportCSV()">Xu·∫•t logfile</button>
            <button id="syncBtn" class="sync-btn" onclick="syncToSheet()">ƒê·ªìng b·ªô Google Sheet</button>
            <button onclick="endShiftReport()">B√°o c√°o cu·ªëi ca</button>
          </div>

          <!-- Bi·ªÉu ƒë·ªì realtime -->
          <div>
            <h3>B√°o c√°o real-time</h3>
            <div style="width: 200px; height: 200px;">
              <canvas id="chartOKNG"></canvas>
            </div>
          </div>
        </div>

        <!-- C·ªôt ph·∫£i -->
        <div class="right">
          <!-- B·ªô l·ªçc -->
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
            <input type="text" id="searchBox" placeholder="T√¨m QR / M√£ h√†ng" onkeyup="renderTable()">
            <select id="filterResult" onchange="renderTable()">
              <option value="">--T·∫•t c·∫£--</option>
              <option value="OK">OK</option>
              <option value="NG">NG</option>
            </select>
          </div>
          <table id="logTable">
            <thead>
              <tr>
                <th>M√£ h√†ng</th>
                <th>QR Code</th>
                <th>Ph√¢n ƒë·ªãnh</th>
                <th>M√¥ t·∫£ l·ªói</th>
                <th>Ng√†y</th>
                <th>Gi·ªù</th>
                <th>S·ªë l·∫ßn xu·∫•t hi·ªán</th>
                <th>M√£ nh√¢n vi√™n</th>
                <th>Shift</th>
                <th>PO</th>
                <th>Ghi ch√∫</th>
                <th>Thao t√°c</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- Tab 2: D·ªØ li·ªáu PRO (TEST) -->
    <div id="tab2" class="tab-content">
      <h3>üßæ D·ªÆ LI·ªÜU PRO (TEST)</h3>
      <p class="ref-status" id="refStatus">‚è≥ ƒêang ch·ªù t·∫£i d·ªØ li·ªáu PRO...</p>
      <div style="margin-bottom:10px;">
        <small>URL PRO Sheet:</small>
        <div style="margin-top:6px;">
          <input type="text" id="refUrlPreview" style="width:60%" readonly>
        </div>
      </div>

      <div style="height:400px; overflow:auto; border:1px solid #ccc; border-radius:6px; padding:8px;">
        <table id="refTable" style="width:100%; border-collapse:collapse;">
          <thead>
            <tr>
              <th>M√£ h√†ng</th>
              <th>QR code</th>
              <th>Ph√°n ƒë·ªãnh</th>
              <th>M√¥ t·∫£ l·ªói</th>
              <th>Gi·ªù</th>
              <th>Ng√†y</th>
              <th>S·ªë l·∫ßn xu·∫•t hi·ªán</th>
              <th>M√£ Nh√¢n Vi√™n</th>
              <th>Ca l√†m vi·ªác</th>
              <th>PO</th>
              <th>Ghi ch√∫</th>
            </tr>
          </thead>
          <tbody id="refTableBody"></tbody>
        </table>
      </div>
      <div id="refCount" style="margin-top:8px;font-weight:bold;"></div>
    </div>
      
    <!-- Tab 3: PQC -->
    <div id="tab3" class="tab-content">
      <h3>üîß D·ªÆ LI·ªÜU PQC</h3>
      <p class="ref-status" id="sauTestStatus">‚è≥ ƒêang ch·ªù t·∫£i d·ªØ li·ªáu PQC...</p>
      <div style="margin-bottom:10px;">
        <small>URL L·∫Øp R√°p Sheet:</small>
        <div style="margin-top:6px;">
          <input type="text" id="sauTestUrlPreview" style="width:60%" readonly>
        </div>
      </div>

      <div style="height:400px; overflow:auto; border:1px solid #ccc; border-radius:6px; padding:8px;">
        <table id="sauTestTable" style="width:100%; border-collapse:collapse;">
          <thead>
            <tr>
              <th>M√£ h√†ng</th>
              <th>QR code</th>
              <th>Ph√°n ƒë·ªãnh</th>
              <th>M√¥ t·∫£ l·ªói</th>
              <th>Gi·ªù</th>
              <th>Ng√†y</th>
              <th>S·ªë l·∫ßn xu·∫•t hi·ªán</th>
              <th>M√£ Nh√¢n Vi√™n</th>
              <th>Ca l√†m vi·ªác</th>
              <th>PO</th>
              <th>Ghi ch√∫</th>
            </tr>
          </thead>
          <tbody id="sauTestTableBody"></tbody>
        </table>
      </div>
      <div id="sauTestCount" style="margin-top:8px;font-weight:bold;"></div>
    </div>
      
    <!-- Tab 4: D·ªØ li·ªáu QC (OQC) -->
    <div id="tab4" class="tab-content">
      <h3>üìë D·ªÆ LI·ªÜU QC (OQC)</h3>
      <div class="filter-container">
        <div class="filter-item">
          <label for="fromDate">T·ª´ ng√†y</label>
          <input type="date" id="fromDate">
        </div>
        <div class="filter-item">
          <label for="toDate">ƒê·∫øn ng√†y</label>
          <input type="date" id="toDate">
        </div>
        <div class="filter-item">
          <label for="maSP">M√£ s·∫£n ph·∫©m</label>
          <select id="maSP"><option value="">T·∫•t c·∫£ m√£</option></select>
        </div>
        <div class="filter-item">
          <label for="searchQR">T√¨m QR Code</label>
          <input type="text" id="searchQR" placeholder="Nh·∫≠p QR Code ƒë·ªÉ l·ªçc..." oninput="applyFilters()">
        </div>
        <div class="filter-item">
          <label for="po">PO</label>
          <select id="po"><option value="">T·∫•t c·∫£ PO</option></select>
        </div>
      </div>

      <div class="button-container">
        <button class="btn-filter" onclick="applyFilters()">L·ªçc d·ªØ li·ªáu</button>
        <button class="btn-download" onclick="reloadFromGoogle()">‚≠Æ T·∫£i t·ª´ Google Sheets</button>
        <button class="btn-reset" onclick="resetFilters()">üóëÔ∏è X√≥a b·ªô l·ªçc</button>
      </div>

      <div id="scrollArea" style="height:500px; overflow:auto; border:1px solid #ccc;">
        <table id="reportTable" style="width:100%; border-collapse:collapse;">
          <thead>
            <tr>
              <th>M√£ H√†ng</th>
              <th>QR Code</th>
              <th>Ph√°n ƒë·ªãnh</th>
              <th>M√¥ t·∫£ l·ªói</th>
              <th>Gi·ªù</th>
              <th>Ng√†y</th>
              <th>S·ªë l·∫ßn xu·∫•t hi·ªán</th>
              <th>M√£ nh√¢n vi√™n</th>
              <th>Ca</th>
              <th>PO</th>
              <th>Ghi ch√∫</th>
            </tr>
          </thead>
          <tbody id="clusterize-content" class="clusterize-content"></tbody>
        </table>
        <div id="clusterize-scroll" class="clusterize-scroll"></div>
      </div>
      <div id="recordCount" style="margin-top:5px; font-weight:bold;"></div>
    </div>
      
    <!-- Tab 5: Bi·ªÉu ƒë·ªì -->
    <div id="tab5" class="tab-content">
      <div class="chart-container">
        <h3>üìä Bi·ªÉu ƒë·ªì Pareto (theo M√¥ t·∫£ l·ªói)</h3>
        <div style="height: 400px;">
          <canvas id="paretoChart"></canvas>
        </div>
      </div>
      
      <div class="chart-container">
        <h3>üìà Bi·ªÉu ƒë·ªì so s√°nh theo ng√†y</h3>
        <div style="height: 400px;">
          <canvas id="dailyChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===================== C·∫§U H√åNH 3 GOOGLE SHEETS =====================
    const PRO_SHEET_URL = "https://script.google.com/macros/s/AKfycbwGCEDo7faBhEh9FCv1ZlrfINyAvfwIg9EbXk-CqwZRYBKVOQJP2hIGjI02JbeWIYJC5A/exec";
    const LAP_RAP_SHEET_URL = "https://script.google.com/macros/s/AKfycbylfaBg90qt9o8fWu83cevhmAXKn3Azg1ivs0NLC62TxtSKlDvT4xuuiO00y1mUPQI9nw/exec";
    const QC_SHEET_URL = "https://script.google.com/macros/s/AKfycbwOt6HhlzmBT2PbhA_0qfwF7rlcrJ4XVPVQcPlh4YeswQ90DQ6rDYmCZl8OV6kqUtV1/exec";

    // Bi·∫øn to√†n c·ª•c cho 3 datasets
    let proData = [];      // D·ªØ li·ªáu t·ª´ Sheet 1 (PRO)
    let sauTestData = [];  // D·ªØ li·ªáu t·ª´ Sheet 2 (L·∫Øp R√°p)
    let qcData = [];       // D·ªØ li·ªáu t·ª´ Sheet 3 (QC)
    let allData = [];      // Gi·ªØ cho t∆∞∆°ng th√≠ch

    // ===================== H√ÄM X·ª¨ L√ù NG√ÄY TH√ÅNG =====================
    function parseDateImproved(dateStr) {
        if (!dateStr) return null;
        
        // Chuy·ªÉn th√†nh string
        dateStr = dateStr.toString().trim();
        
        // ƒê·ªãnh d·∫°ng dd/mm/yyyy
        let match = dateStr.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
        if (match) {
            const day = parseInt(match[1], 10);
            const month = parseInt(match[2], 10) - 1;
            const year = parseInt(match[3], 10);
            return new Date(year, month, day);
        }
        
        // ƒê·ªãnh d·∫°ng yyyy-mm-dd
        match = dateStr.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
        if (match) {
            const year = parseInt(match[1], 10);
            const month = parseInt(match[2], 10) - 1;
            const day = parseInt(match[3], 10);
            return new Date(year, month, day);
        }
        
        // ƒê·ªãnh d·∫°ng timestamp
        if (dateStr.includes('T')) {
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
                // Ch·ªâ l·∫•y ph·∫ßn ng√†y, b·ªè qua gi·ªù
                return new Date(date.getFullYear(), date.getMonth(), date.getDate());
            }
        }
        
        // Th·ª≠ parse tr·ª±c ti·∫øp
        const date = new Date(dateStr);
        if (!isNaN(date.getTime())) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate());
        }
        
        return null;
    }

    function formatDateForDisplay(date) {
        if (!date || isNaN(date.getTime())) return '';
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${day}/${month}/${year}`;
    }

    function getDateRange(startDate, endDate) {
        const dates = [];
        const current = new Date(startDate);
        const end = new Date(endDate);
        
        while (current <= end) {
            dates.push(new Date(current));
            current.setDate(current.getDate() + 1);
        }
        
        return dates;
    }

    // ===================== TAB UI =====================
    function showTab(n) {
      document.querySelectorAll('.tab-buttons button').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
      document.getElementById('btnTab' + n).classList.add('active');
      document.getElementById('tab' + n).classList.add('active');
    }

    // ===== PH·∫¶N PH√ÅN ƒê·ªäNH S·∫¢N PH·∫®M =====
    const users = {
      "5035": "123456",
      "3062": "223456", // HI·∫æU
      "5053": "334567", // LY
      "5088": "445678", // QU·ª≤NH
      "5383": "556789", // VY
      "5381": "667890", // OANH
      "5623": "778901", // PH√ÅT 
      "5718": "889012", // NGA
      "5628": "990123", // TH√ÄNH
      "5720": "112345", // M·ª∏
      "5264": "001234", // KH√ÅNH
      "4810": "1903", // C.TRANG
    };
    
    // C·∫•u h√¨nh gi·ªõi h·∫°n k√Ω t·ª± QR code theo m√£ h√†ng
    const qrCodeLimits = {
  "ECM-2583-236": 30,
  "ECM-2583-164": 30,
  "ECM-2300": 30,
  "ECM-2310": 30,
  "IZ-1-R3": 49,
  "RM-4K-R3": 49,
  "P-7937": 35,
  "P-8105": 35,
  "P-8149": 35,
  "BMS 85AH": 27,
  "BMS 57AH": 27,
  "CONTROLLER": 27,
  "CAS NEMO": 25,
  "CAS MINI-DI": 25,
  "CAS MINI-485": 25,
  "BN 2573A": 20,
  "OEM": 15
};
     // Th√™m s·ª± ki·ªán khi thay ƒë·ªïi m√£ h√†ng
    document.getElementById("mahang").addEventListener("change", function() {
  showQRLimitInfo(this.value);
   });

   function showQRLimitInfo(mahang) {
  const limit = qrCodeLimits[mahang] || 50;
  const infoElement = document.getElementById("qrLimitInfo");
  
  if (!infoElement) {
    // T·∫°o element n·∫øu ch∆∞a c√≥
    const newInfo = document.createElement("div");
    newInfo.id = "qrLimitInfo";
    newInfo.className = "small";
    newInfo.style.color = "#e67e22";
    newInfo.style.marginTop = "5px";
    document.querySelector('label[for="qrcode"]').parentNode.appendChild(newInfo);
  }
  
  document.getElementById("qrLimitInfo").textContent = 
    `Gi·ªõi h·∫°n QR code: ${limit} k√Ω t·ª±`;
   }
    // records[0] l√† header
    let records = [["M√£ h√†ng","QR Code","K·∫øt qu·∫£","L·ªói","Gi·ªù","Ng√†y","S·ªë l·∫ßn xu·∫•t hi·ªán","Ng∆∞·ªùi ki·ªÉm tra","Ca","WO","Ghi ch√∫","Synced"]];
    let qrCounter = {};
    let currentUser = "";
    let currentShift = "";
    let currentWO = "";
    let okCount = 0, ngCount = 0;
    let chart;

    let deliveryTarget = 0;
    let deliveryCounter = 0;

    // Load t·ª´ localStorage (records + qrCounter)
    if (localStorage.getItem("records")) {
      try { 
        const savedRecords = JSON.parse(localStorage.getItem("records"));
        if (Array.isArray(savedRecords) && savedRecords.length > 0) {
          records = savedRecords;
        }
      } catch(e) { 
        console.error("L·ªói khi load records t·ª´ localStorage:", e);
      }
    }
    
    if (localStorage.getItem("qrCounter")) {
      try { 
        qrCounter = JSON.parse(localStorage.getItem("qrCounter")); 
      } catch(e) { 
        console.error("L·ªói khi load qrCounter t·ª´ localStorage:", e);
      }
    }

    // ===================== Utility =====================
    function findLastRecordIndex(qrcode) {
      for (let i = records.length - 1; i >= 1; i--) {
        if (records[i][1] === qrcode) return i;
      }
      return -1;
    }

    function recomputeCountsForShift(shift) {
      let ok = 0, ng = 0;
      const latestResults = {};
      for (let i = 1; i < records.length; i++) {
        const row = records[i];
        if (row[8] === shift) {
          const qrcode = row[1];
          if (!latestResults[qrcode] || i > latestResults[qrcode].index) {
            latestResults[qrcode] = { result: row[2], index: i };
          }
        }
      }
      for (const qrcode in latestResults) {
        if (latestResults[qrcode].result === "OK") ok++;
        else if (latestResults[qrcode].result === "NG") ng++;
      }
      okCount = ok; 
      ngCount = ng;
      document.getElementById("okCount").textContent = okCount;
      document.getElementById("ngCount").textContent = ngCount;
      updateChart();
    }

    // ===================== Login =====================
    function login() {
      const uRaw = document.getElementById("loginUser").value.trim();
      const p = document.getElementById("loginPass").value.trim();
      const s = document.getElementById("shift").value;
      const wo = document.getElementById("wo").value.trim();
      
      if (!uRaw || !wo) { 
        document.getElementById("loginError").textContent = "‚ö†Ô∏è Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß!"; 
        return; 
      }
      
      const u = uRaw.toUpperCase();
      if (users[u] && users[u] === p) {
        currentUser = u;
        currentShift = s;
        currentWO = wo;
        document.getElementById("currentUser").textContent = currentUser;
        document.getElementById("currentShift").textContent = currentShift;
        document.getElementById("currentWO").textContent = currentWO;
        document.getElementById("loginScreen").style.display = "none";
        document.getElementById("mainApp").style.display = "flex";
        recomputeCountsForShift(currentShift);
        renderTable();
      } else {
        document.getElementById("loginError").textContent = "‚ö†Ô∏è Sai t√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u!";
      }
    }

    document.getElementById("deliveryQty").addEventListener("input", ()=>{
      deliveryTarget = parseInt(document.getElementById("deliveryQty").value) || 0;
      deliveryCounter = 0;
      if (deliveryTarget > 0) {
        document.getElementById("deliveryStatus").textContent = `üîÑ ƒê√£ ƒë·∫∑t m·ª•c ti√™u: ${deliveryTarget}`;
      } else {
        document.getElementById("deliveryStatus").textContent = "";
      }
    });

    // ===================== Save / Update log =====================
    function saveData(result) {
  // Ki·ªÉm tra s·ªë l∆∞·ª£ng giao
  if (deliveryTarget === 0) {
    alert("‚ö†Ô∏è Vui l√≤ng nh·∫≠p S·ªê L∆Ø·ª¢NG GIAO tr∆∞·ªõc khi qu√©t!");
    return;
  }

  if (deliveryCounter >= deliveryTarget) {
    alert("‚ö†Ô∏è ƒê√£ ƒë·ªß s·ªë l∆∞·ª£ng giao, kh√¥ng th·ªÉ qu√©t th√™m!");
    return;
  }

  const mahang = document.getElementById("mahang").value.trim().toUpperCase();
  const qrcode = document.getElementById("qrcode").value.trim().toUpperCase();
  const loi = document.getElementById("loi").value.trim();
  const ghichu = document.getElementById("ghichu").value.trim();

  if (!mahang || !qrcode) {
    document.getElementById("error").textContent = "‚ö†Ô∏è Vui l√≤ng nh·∫≠p M√£ h√†ng v√† QR Code!";
    return;
  }
  
  const limit = qrCodeLimits[mahang] || 50; // M·∫∑c ƒë·ªãnh 50 k√Ω t·ª± n·∫øu kh√¥ng c√≥ c·∫•u h√¨nh
  if (qrcode.length > limit) {
  alert(`‚ö†Ô∏è QR Code qu√° d√†i!\nM√£ h√†ng ${mahang} ch·ªâ cho ph√©p t·ªëi ƒëa ${limit} k√Ω t·ª±.\nS·ªë k√Ω t·ª± hi·ªán t·∫°i: ${qrcode.length}`);
  document.getElementById("qrcode").value = "";
  document.getElementById("qrcode").focus();
  checkQRStatus("");
  return;
  }

  document.getElementById("error").textContent = "";

  // Ki·ªÉm tra tr√πng l·∫∑p trong local records
  const existedOK = records.some(r => r[1] === qrcode && r[2] === "OK");
  if (existedOK) {
    alert("‚ö†Ô∏è S·∫£n ph·∫©m n√†y ƒë√£ ƒë∆∞·ª£c ƒë√°nh gi√° OK tr∆∞·ªõc ƒë√≥ (local)!");
    document.getElementById("qrcode").value = "";
    document.getElementById("qrcode").focus();
    checkQRStatus("");
    return;
  }

  // Ti·∫øp t·ª•c l∆∞u d·ªØ li·ªáu
  qrCounter[qrcode] = (qrCounter[qrcode] || 0) + 1;
  const now = new Date();
  const gio = now.toLocaleTimeString("vi-VN");
  const ngay = now.toLocaleDateString("vi-VN");

  // C·∫≠p nh·∫≠t counts
  let oldOkCount = 0, oldNgCount = 0;
  for (let i = 1; i < records.length; i++) {
    if (records[i][1] === qrcode) {
      if (records[i][2] === "OK") oldOkCount++;
      else if (records[i][2] === "NG") oldNgCount++;
    }
  }
  okCount = okCount - oldOkCount;
  ngCount = ngCount - oldNgCount;
  if (result === "OK") okCount++; else ngCount++;

  records.push([
    mahang,
    qrcode,
    result,
    loi,
    gio,
    ngay,
    qrCounter[qrcode],
    currentUser,
    currentShift,
    currentWO,
    ghichu,
    false
  ]);

  saveLocal();
  renderTable();
  document.getElementById("okCount").textContent = okCount;
  document.getElementById("ngCount").textContent = ngCount;
  updateChart();

  document.getElementById("qrcode").value = "";
  document.getElementById("loi").value = "";
  document.getElementById("ghichu").value = "";
  
  deliveryCounter++;
  document.getElementById("deliveryStatus").textContent = `ƒê√£ qu√©t ${deliveryCounter}/${deliveryTarget}`;

  if (deliveryCounter >= deliveryTarget) {
    alert(`‚úÖ ƒê√£ ƒë·ªß ${deliveryTarget} s·∫£n ph·∫©m!`);
    document.getElementById("deliveryQty").value = 0;
    deliveryTarget = 0;
    deliveryCounter = 0;
    document.getElementById("deliveryStatus").textContent = "";
  }

  const qEl = document.getElementById("qrcode");
  if (qEl) {
    qEl.focus();
    qEl.select();
  }

  // üöÄ ƒê·ªìng b·ªô NG OK l√™n Google Sheet ngay l·∫≠p t·ª©c
  if (result === "NG" || result === "OK") {
    const lastRecord = records[records.length - 1];
    const dataToSend = [lastRecord];

    fetch(QC_SHEET_URL, {
      method: "POST",
      body: JSON.stringify(dataToSend),
      headers: { "Content-Type": "application/json" },
      mode: "no-cors"
    })
    .then(() => {
      console.log("‚úÖ ƒê√£ g·ª≠i d√≤ng NG l√™n Google Sheet:", lastRecord[1]);
      lastRecord[11] = true;
      saveLocal();
    })
    .catch(err => {
      console.error("‚ùå L·ªói ƒë·ªìng b·ªô NG:", err);
    });
  }

  checkQRStatus("");
}

    // ===================== Render b·∫£ng (local) =====================
    function renderTable() {
      const tbody = document.getElementById("logTable").getElementsByTagName("tbody")[0];
      tbody.innerHTML = "";

      const search = document.getElementById("searchBox").value.toLowerCase();
      const filterRes = document.getElementById("filterResult").value;

      for (let i = records.length - 1; i >= 1; i--) {
        const rowData = records[i];
        
        if (search && !rowData[0].toLowerCase().includes(search) && !rowData[1].toLowerCase().includes(search)) continue;
        if (filterRes && rowData[2] !== filterRes) continue;

        const tr = tbody.insertRow();
        
        let bgColor = "white";
        if (rowData[2] === "NG") {
          bgColor = "red";
        } else if (rowData[2] === "OK") {
          const hasPreviousNG = checkIfHasPreviousNG(rowData[1], i);
          if (hasPreviousNG) {
            bgColor = "#27ae60";
          } else {
            bgColor = "white";
          }
        }
        tr.style.backgroundColor = bgColor;

        for (let j = 0; j < 11; j++) {
          const td = tr.insertCell();
          td.textContent = rowData[j] || "";
        }

        const tdDel = tr.insertCell();
        const btn = document.createElement("button");
        btn.textContent = "X√≥a";
        btn.style.background = "#e74c3c";
        btn.style.color = "white";
        btn.style.border = "none";
        btn.style.padding = "4px 8px";
        btn.style.borderRadius = "4px";
        btn.onclick = () => deleteRecord(i);
        tdDel.appendChild(btn);

        if ((rowData[6] || 0) > 1) tr.classList.add("duplicate");
      }
    }

    function checkIfHasPreviousNG(qrcode, currentIndex) {
      for (let i = currentIndex - 1; i >= 1; i--) {
        if (records[i][1] === qrcode && records[i][2] === "NG") {
          return true;
        }
      }
      return false;
    }

    // ===================== L∆∞u local =====================
    function saveLocal() {
      try {
        localStorage.setItem("records", JSON.stringify(records));
        localStorage.setItem("qrCounter", JSON.stringify(qrCounter));
      } catch(e) { 
        console.warn("L∆∞u localStorage th·∫•t b·∫°i:", e); 
      }
    }

    // ===================== Xu·∫•t CSV =====================
    function exportCSV() {
      if (!currentShift || !currentWO) {
        alert("‚ö†Ô∏è Vui l√≤ng ƒëƒÉng nh·∫≠p v√† ch·ªçn ca + WO tr∆∞·ªõc khi xu·∫•t file!");
        return;
      }

      let mahang = document.getElementById("mahang").value.trim();
      if (!mahang) { 
        alert("‚ö†Ô∏è Vui l√≤ng nh·∫≠p m√£ h√†ng tr∆∞·ªõc khi xu·∫•t file!"); 
        return; 
      }

      let filteredRecords = [["M√£ h√†ng","QR Code","K·∫øt qu·∫£","L·ªói","Gi·ªù","Ng√†y","S·ªë l·∫ßn xu·∫•t hi·ªán","Ng∆∞·ªùi ki·ªÉm tra","Ca","WO","Ghi ch√∫"]];
      for (let i = 1; i < records.length; i++) {
        if (records[i][8] === currentShift && records[i][9] === currentWO) {
          filteredRecords.push(records[i]);
        }
      }

      if (filteredRecords.length <= 1) {
        alert("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu n√†o cho ca n√†y!");
        return;
      }

      let now = new Date();
      let filename = `${mahang}_${currentShift.replace(/\s+/g, "_")}_${now.getFullYear()}-${now.getMonth()+1}-${now.getDate()}.csv`;

      let csvContent = "\uFEFF" + filteredRecords.map(e => e.join(",")).join("\n");
      let blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      let link = document.createElement("a");
      if (link.download !== undefined) {
        let url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }

    // ===================== Sync Google Sheets (main) =====================
    function syncToSheet() {
  const sheetUrl = "https://script.google.com/macros/s/AKfycbwOt6HhlzmBT2PbhA_0qfwF7rlcrJ4XVPVQcPlh4YeswQ90DQ6rDYmCZl8OV6kqUtV1/exec"; 
  
  // üîπ THAY ƒê·ªîI: G·ª≠i to√†n b·ªô records (bao g·ªìm c·∫£ ghi ch√∫)
  const dataToSend = records
  .slice(1)
  .filter(r => !r[11]); // üîπ ch·ªâ l·∫•y d√≤ng ch∆∞a sync


  if (dataToSend.length === 0) {
    alert("‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ ƒë·ªìng b·ªô!");
    return;
  }

  console.log("D·ªØ li·ªáu g·ª≠i l√™n Google Sheets:", dataToSend); // Debug

  fetch(sheetUrl, {
    method: "POST",
    body: JSON.stringify(dataToSend),
    headers: { "Content-Type": "application/json" },
    mode: "no-cors"
  })
  .then(() => {
  alert("‚úÖ ƒê√£ g·ª≠i d·ªØ li·ªáu l√™n Google Sheets");

  // üîπ ƒê√°nh d·∫•u c√°c d√≤ng ƒë√£ g·ª≠i
  records = records.map(r => {
    if (r[11] === false) r[11] = true;
    return r;
  });
  saveLocal();

  console.log("ƒê√£ ƒë√°nh d·∫•u synced:", records);
})

  .catch(err => {
    alert("‚ùå L·ªói ƒë·ªìng b·ªô: " + err);
    console.error("L·ªói g·ª≠i d·ªØ li·ªáu:", err);
  });
}

    // ===================== B√°o c√°o cu·ªëi ca =====================
    function endShiftReport() {
      let summary = {};
      for (let i = 1; i < records.length; i++) {
        if (records[i][8] === currentShift && records[i][9] === currentWO) {
          let mahang = records[i][0];
          let result = records[i][2];
          let loi = records[i][3];

          if (!summary[mahang]) {
            summary[mahang] = { ok: 0, ng: 0, loiCount: {} };
          }

          if (result === "OK") {
            summary[mahang].ok++;
          } else if (result === "NG") {
            summary[mahang].ng++;
            summary[mahang].loiCount[loi] = (summary[mahang].loiCount[loi] || 0) + 1;
          }
        }
      }

      let report = `üìä B√°o c√°o ca ${currentShift} (WO: ${currentWO}):\n`;
      for (let mahang in summary) {
        let ok = summary[mahang].ok;
        let ng = summary[mahang].ng;
        let total = ok + ng;
        let tyLeNG = total ? ((ng / total) * 100).toFixed(2) : 0;
        let top3 = Object.entries(summary[mahang].loiCount)
                         .sort((a,b)=>b[1]-a[1])
                         .slice(0,3)
                         .map(x => `${x[0]}(${x[1]})`)
                         .join(", ") || "Kh√¥ng c√≥";

        report += `\nüì¶ M√£ h√†ng: ${mahang}\n‚úÖ OK: ${ok} | ‚ùå NG: ${ng} | üìâ T·ª∑ l·ªá NG: ${tyLeNG}%\nüî• Top l·ªói: ${top3}\n`;
      }

      alert(report);
    }

    // ===================== Chart =====================
    function updateChart() {
      const canvas = document.getElementById("chartOKNG");
      if (!canvas) return;
      
      const ctx = canvas.getContext("2d");
      if (chart) chart.destroy();
      
      try {
        chart = new Chart(ctx, {
          type: "doughnut",
          data: {
            labels: ["OK", "NG"],
            datasets: [{
              data: [okCount, ngCount],
              backgroundColor: ["#2ecc71", "#e74c3c"]
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: "50%",
            radius: "90%",
            plugins: { 
              legend: { 
                position: "right",
                labels: {
                  usePointStyle: true,
                  padding: 20
                }
              }
            }
          }
        });
      } catch(e) {
        console.error("L·ªói khi t·∫°o bi·ªÉu ƒë·ªì:", e);
      }
    }

    // ===================== X√≥a log ch·ªâ UI =====================
    function clearLogDisplay() {
      if (!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a b·∫£ng hi·ªÉn th·ªã? (D·ªØ li·ªáu v·∫´n c√≤n l∆∞u trong b·ªô nh·ªõ)")) return;
      document.querySelector("#logTable tbody").innerHTML = "";
      alert("‚úÖ ƒê√£ x√≥a hi·ªÉn th·ªã log. D·ªØ li·ªáu g·ªëc v·∫´n c√≤n!");
    }

    // ===================== Reset to√†n b·ªô d·ªØ li·ªáu =====================
    function resetAllData() {
      if (!confirm("‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën X√ìA TO√ÄN B·ªò d·ªØ li·ªáu (records + b·ªô ƒë·∫øm)?")) return;

      const backupKey = "backup_records_" + (new Date()).toISOString();
      try {
        localStorage.setItem(backupKey, JSON.stringify(records));
        localStorage.setItem(backupKey + "_qr", JSON.stringify(qrCounter));
      } catch(e) { console.warn("Backup th·∫•t b·∫°i:", e); }

      records = [["M√£ h√†ng","QR Code","K·∫øt qu·∫£","L·ªói","Gi·ªù","Ng√†y","S·ªë l·∫ßn xu·∫•t hi·ªán","Ng∆∞·ªùi ki·ªÉm tra","Ca","WO","Ghi ch√∫"]];
      qrCounter = {};
      okCount = 0; ngCount = 0;
      saveLocal();

      renderTable();
      recomputeCountsForShift(currentShift || "");
      alert("‚úÖ ƒê√£ reset d·ªØ li·ªáu. B·∫£n backup ƒë√£ l∆∞u v√†o localStorage v·ªõi key: " + backupKey);
    }

    // ===================== X√≥a 1 d√≤ng =====================
    function deleteRecord(index) {
      if (!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a d√≤ng n√†y?")) return;

      index = Number(index);
      if (isNaN(index) || index < 1 || index >= records.length) {
        alert("Kh√¥ng t√¨m th·∫•y b·∫£n ghi ƒë·ªÉ x√≥a.");
        return;
      }

      const removed = records.splice(index, 1)[0];
      const removedQr = removed[1];
      
      recomputeCountsForShift(currentShift);
      
      saveLocal();
      renderTable();
    }

    // ===================== H√ÄM T·∫¢I D·ªÆ LI·ªÜU PRO (SHEET 1) =======
    function loadReferenceData(silent = false) {
      const statusEl = document.getElementById("refStatus");
      const previewEl = document.getElementById("refUrlPreview");
      const refBody = document.getElementById("refTableBody");
      const refCount = document.getElementById("refCount");

      if (!PRO_SHEET_URL || PRO_SHEET_URL.trim() === "") {
        statusEl.innerHTML = "‚ö†Ô∏è PRO_SHEET_URL ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh.";
        statusEl.style.color = "#e67e22";
        return;
      }

      previewEl.value = PRO_SHEET_URL;
      if (!silent) {
        statusEl.textContent = "‚è≥ ƒêang t·∫£i d·ªØ li·ªáu PRO...";
        statusEl.style.color = "black";
      }

      const noCacheUrl = PRO_SHEET_URL + "?t=" + Date.now();
      fetch(noCacheUrl, { method: "GET", mode: "cors", cache: "no-store" })
        .then(res => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .then(data => {
          if (!Array.isArray(data)) throw new Error("D·ªØ li·ªáu PRO kh√¥ng h·ª£p l·ªá");

          proData = data;
          
          if (!silent) {
            statusEl.textContent = `‚úÖ D·ªØ li·ªáu PRO: ${proData.length} d√≤ng`;
            statusEl.style.color = "green";
          }
          
          renderReferenceTable();
        })
        .catch(err => {
          console.error("L·ªói t·∫£i d·ªØ li·ªáu PRO:", err);
          statusEl.innerHTML = `‚ùå L·ªói t·∫£i d·ªØ li·ªáu PRO: ${err.message}`;
          statusEl.style.color = "red";
        });
    }

    function renderReferenceTable() {
      const body = document.getElementById("refTableBody");
      body.innerHTML = "";

      if (!Array.isArray(proData) || proData.length === 0) {
        body.innerHTML = `<tr><td colspan="11" style="color:red;">‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu PRO</td></tr>`;
        document.getElementById("refCount").textContent = "0 d√≤ng";
        return;
      }

      // H√†m chuy·ªÉn ƒë·ªïi timestamp th√†nh gi·ªù th·ª±c t·∫ø - FIXED
      function convertTimestampToTime(timestamp) {
        if (!timestamp) return "";
        
        // N·∫øu ƒë√£ l√† gi·ªù d·∫°ng HH:mm:ss th√¨ gi·ªØ nguy√™n
        if (typeof timestamp === "string" && timestamp.match(/^\d{1,2}:\d{1,2}:\d{1,2}$/)) {
          return timestamp;
        }
        
        // N·∫øu l√† timestamp t·ª´ Google Sheets (d·∫°ng 1899-12-30T04:15:25.000Z)
        if (typeof timestamp === "string" && timestamp.includes("T")) {
          try {
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return timestamp;
            
            // S·ª≠a l·ªói: Google Sheets timestamp th∆∞·ªùng l√† serial number, kh√¥ng ph·∫£i real timestamp
            const baseDate = new Date('1899-12-30');
            const diffMs = date.getTime() - baseDate.getTime();
            const correctedDate = new Date(baseDate.getTime() + diffMs);
            
            // L·∫•y gi·ªù ch√≠nh x√°c
            const hours = String(correctedDate.getHours()).padStart(2, '0');
            const minutes = String(correctedDate.getMinutes()).padStart(2, '0');
            const seconds = String(correctedDate.getSeconds()).padStart(2, '0');
            
            return `${hours}:${minutes}:${seconds}`;
          } catch (e) {
            console.error("L·ªói convert time:", e);
            return timestamp;
          }
        }
        
        return timestamp;
      }

      // H√†m chuy·ªÉn ƒë·ªïi timestamp th√†nh ng√†y th·ª±c t·∫ø
      function convertTimestampToDate(timestamp) {
        if (!timestamp) return "";
        
        // N·∫øu ƒë√£ l√† ng√†y d·∫°ng dd/mm/yyyy th√¨ gi·ªØ nguy√™n
        if (typeof timestamp === "string" && timestamp.match(/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4}$/)) {
          return timestamp;
        }
        
        // N·∫øu l√† timestamp t·ª´ Google Sheets
        if (typeof timestamp === "string" && timestamp.includes("T")) {
          try {
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return timestamp;
            
            // S·ª≠a l·ªói t∆∞∆°ng t·ª± nh∆∞ v·ªõi gi·ªù
            const baseDate = new Date('1899-12-30');
            const diffMs = date.getTime() - baseDate.getTime();
            const correctedDate = new Date(baseDate.getTime() + diffMs);
            
            // Format th√†nh ng√†y Vi·ªát Nam
            return correctedDate.toLocaleDateString("vi-VN");
          } catch (e) {
            console.error("L·ªói convert date:", e);
            return timestamp;
          }
        }
        
        return timestamp;
      }

      proData.forEach((r) => {
        const tr = document.createElement("tr");

        const cells = [
          r["M√£ h√†ng"] || r.maHang || "",
          r["QR Code"] || r["QR code"] || r.qrCode || r.qr || "",
          r["Ph√°n ƒë·ªãnh"] || r["K·∫øt qu·∫£"] || r.phanDinh || "",
          r["M√¥ t·∫£ l·ªói"] || r.moTaLoi || "",
          convertTimestampToTime(r["Gi·ªù"] || r.gio || r["Time"]), // Chuy·ªÉn ƒë·ªïi gi·ªù
          convertTimestampToDate(r["Ng√†y"] || r.ngay || r["Date"]), // Chuy·ªÉn ƒë·ªïi ng√†y
          r["S·ªë l·∫ßn xu·∫•t hi·ªán"] || r.soLan || "",
          r["M√£ Nh√¢n Vi√™n"] || r.maNV || r.User || "",
          r["Ca l√†m vi·ªác"] || r.caLam || r.Shift || "",
          r["PO"] || r.po || "",
          r["Ghi ch√∫"] || r.ghichu || "",
        ];

        cells.forEach((c) => {
          const td = document.createElement("td");
          td.textContent = c;
          tr.appendChild(td);
        });

        body.appendChild(tr);
      });

      document.getElementById("refCount").textContent = `T·ªïng PRO data: ${proData.length} d√≤ng`;
    }

    // ===================== H√ÄM T·∫¢I D·ªÆ LI·ªÜU PQC (SHEET 2) =======
    function loadSauTestData(silent = false) {
      const statusEl = document.getElementById("sauTestStatus");
      const previewEl = document.getElementById("sauTestUrlPreview");
      const sauTestBody = document.getElementById("sauTestTableBody");
      const sauTestCount = document.getElementById("sauTestCount");

      if (!LAP_RAP_SHEET_URL || LAP_RAP_SHEET_URL.trim() === "") {
        statusEl.innerHTML = "‚ö†Ô∏è LAP_RAP_SHEET_URL ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh.";
        statusEl.style.color = "#e67e22";
        return;
      }

      previewEl.value = LAP_RAP_SHEET_URL;
      if (!silent) {
        statusEl.textContent = "‚è≥ ƒêang t·∫£i d·ªØ li·ªáu PQC...";
        statusEl.style.color = "black";
      }

      const noCacheUrl = LAP_RAP_SHEET_URL + "?t=" + Date.now();
      fetch(noCacheUrl, { method: "GET", mode: "cors", cache: "no-store" })
        .then(res => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .then(data => {
          if (!Array.isArray(data)) throw new Error("D·ªØ li·ªáu L·∫Øp R√°p kh√¥ng h·ª£p l·ªá");

          sauTestData = data;
          
          if (!silent) {
            statusEl.textContent = `‚úÖ D·ªØ li·ªáu PQC: ${sauTestData.length} d√≤ng`;
            statusEl.style.color = "green";
          }
          
          renderSauTestTable();
        })
        .catch(err => {
          console.error("L·ªói t·∫£i d·ªØ li·ªáu PQC:", err);
          statusEl.innerHTML = `‚ùå L·ªói t·∫£i d·ªØ li·ªáu PQC: ${err.message}`;
          statusEl.style.color = "red";
        });
    }

    function renderSauTestTable() {
      const body = document.getElementById("sauTestTableBody");
      body.innerHTML = "";

      if (!Array.isArray(sauTestData) || sauTestData.length === 0) {
        body.innerHTML = `<tr><td colspan="11" style="color:red;">‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu PQC</td></tr>`;
        document.getElementById("sauTestCount").textContent = "0 d√≤ng";
        return;
      }

      // H√†m chuy·ªÉn ƒë·ªïi timestamp th√†nh gi·ªù th·ª±c t·∫ø
      function convertTimestampToTime(timestamp) {
        if (!timestamp) return "";
        
        if (typeof timestamp === "string" && timestamp.match(/^\d{1,2}:\d{1,2}:\d{1,2}$/)) {
          return timestamp;
        }
        
        if (typeof timestamp === "string" && timestamp.includes("T")) {
          try {
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return timestamp;
            
            const baseDate = new Date('1899-12-30');
            const diffMs = date.getTime() - baseDate.getTime();
            const correctedDate = new Date(baseDate.getTime() + diffMs);
            
            const hours = String(correctedDate.getHours()).padStart(2, '0');
            const minutes = String(correctedDate.getMinutes()).padStart(2, '0');
            const seconds = String(correctedDate.getSeconds()).padStart(2, '0');
            
            return `${hours}:${minutes}:${seconds}`;
          } catch (e) {
            console.error("L·ªói convert time:", e);
            return timestamp;
          }
        }
        
        return timestamp;
      }

      // H√†m chuy·ªÉn ƒë·ªïi timestamp th√†nh ng√†y th·ª±c t·∫ø
      function convertTimestampToDate(timestamp) {
        if (!timestamp) return "";
        
        if (typeof timestamp === "string" && timestamp.match(/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4}$/)) {
          return timestamp;
        }
        
        if (typeof timestamp === "string" && timestamp.includes("T")) {
          try {
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return timestamp;
            
            const baseDate = new Date('1899-12-30');
            const diffMs = date.getTime() - baseDate.getTime();
            const correctedDate = new Date(baseDate.getTime() + diffMs);
            
            return correctedDate.toLocaleDateString("vi-VN");
          } catch (e) {
            console.error("L·ªói convert date:", e);
            return timestamp;
          }
        }
        
        return timestamp;
      }

      sauTestData.forEach((r) => {
        const tr = document.createElement("tr");

        const cells = [
          r["M√£ h√†ng"] || r.maHang || "",
          r["QR Code"] || r["QR code"] || r.qrCode || r.qr || "",
          r["Ph√°n ƒë·ªãnh"] || r["K·∫øt qu·∫£"] || r.phanDinh || "",
          r["M√¥ t·∫£ l·ªói"] || r.moTaLoi || "",
          convertTimestampToTime(r["Gi·ªù"] || r.gio || r["Time"]),
          convertTimestampToDate(r["Ng√†y"] || r.ngay || r["Date"]),
          r["S·ªë l·∫ßn xu·∫•t hi·ªán"] || r.soLan || "",
          r["M√£ Nh√¢n Vi√™n"] || r.maNV || r.User || "",
          r["Ca l√†m vi·ªác"] || r.caLam || r.Shift || "",
          r["PO"] || r.po || "",
          r["Ghi ch√∫"] || r.ghichu || "",
        ];

        cells.forEach((c) => {
          const td = document.createElement("td");
          td.textContent = c;
          tr.appendChild(td);
        });

        body.appendChild(tr);
      });

      document.getElementById("sauTestCount").textContent = `T·ªïng PQC data: ${sauTestData.length} d√≤ng`;
    }

    // ===================== H√ÄM T·∫¢I D·ªÆ LI·ªÜU QC (SHEET 3) - ƒê√É S·ª¨A =======
    function reloadFromGoogle(){
      // L∆∞u tr·∫°ng th√°i l·ªçc hi·ªán t·∫°i
      const currentFilters = {
        searchQR: document.getElementById("searchQR").value,
        fromDate: document.getElementById("fromDate").value,
        toDate: document.getElementById("toDate").value,
        maSP: document.getElementById("maSP").value,
        po: document.getElementById("po").value,
        isFiltered: window.isFiltered || false
      };

      fetch(QC_SHEET_URL + "?t=" + Date.now())
        .then(res=>{
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          return res.json();
        })
        .then(newData=>{
          if (!Array.isArray(newData)) {
            throw new Error("D·ªØ li·ªáu QC kh√¥ng h·ª£p l·ªá");
          }
          
          // L∆∞u s·ªë l∆∞·ª£ng b·∫£n ghi c≈© ƒë·ªÉ so s√°nh
          const oldCount = qcData.length;
          
          // C·∫≠p nh·∫≠t d·ªØ li·ªáu
          qcData = newData;
          allData = qcData;
          
          populateFilters(qcData);
          
          // Kh√¥i ph·ª•c tr·∫°ng th√°i l·ªçc n·∫øu ƒëang filter
          if (currentFilters.isFiltered) {
            document.getElementById("searchQR").value = currentFilters.searchQR;
            document.getElementById("fromDate").value = currentFilters.fromDate;
            document.getElementById("toDate").value = currentFilters.toDate;
            document.getElementById("maSP").value = currentFilters.maSP;
            document.getElementById("po").value = currentFilters.po;
            
            // √Åp d·ª•ng l·∫°i b·ªô l·ªçc
            applyFilters();
            
            console.log(`üîÑ ƒê√£ kh√¥i ph·ª•c b·ªô l·ªçc sau khi c·∫≠p nh·∫≠t d·ªØ li·ªáu`);
          } else {
            // N·∫øu kh√¥ng filter, hi·ªÉn th·ªã to√†n b·ªô d·ªØ li·ªáu
            renderReportTable(qcData);
          }
          
          // V·∫Ω bi·ªÉu ƒë·ªì v·ªõi d·ªØ li·ªáu hi·ªán t·∫°i (ƒë√£ filter ho·∫∑c to√†n b·ªô)
          const dataToDraw = currentFilters.isFiltered ? filteredDataGlobal : qcData;
          if (dataToDraw.length > 0) {
            setTimeout(() => {
              drawPareto(dataToDraw);
              drawDailyChart(dataToDraw);
            }, 100);
          }
          
          // Th√¥ng b√°o n·∫øu c√≥ d·ªØ li·ªáu m·ªõi
          if (newData.length > oldCount) {
            const newCount = newData.length - oldCount;
            console.log(`üìà ƒê√£ c·∫≠p nh·∫≠t th√™m ${newCount} b·∫£n ghi m·ªõi`);
            
            // Hi·ªÉn th·ªã th√¥ng b√°o t·∫°m th·ªùi
            if (document.getElementById('tab4').classList.contains('active')) {
              showTempNotification(`ƒê√£ c·∫≠p nh·∫≠t th√™m ${newCount} b·∫£n ghi m·ªõi`, 3000);
            }
          }
        })
        .catch(err=>{
          console.error("Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu QC:", err);
          // Kh√¥i ph·ª•c l·∫°i d·ªØ li·ªáu c≈© n·∫øu c√≥ l·ªói
          if (currentFilters.isFiltered) {
            applyFilters();
          }
        });
    }

    // ======= H√ÄM KI·ªÇM TRA TR·∫†NG TH√ÅI QR (SO S√ÅNH 3 TAB) =======
    // H√ÄM S·ª¨A L·ªñI - X·ª¨ L√ù ƒê√öNG TH·ªúI GIAN T·ª™ GOOGLE SHEETS
    
    // H√ÄM KI·ªÇM TRA QR STATUS M·ªöI - SO S√ÅNH 3 TAB
    // H√ÄM KI·ªÇM TRA QR STATUS M·ªöI - SO S√ÅNH 3 TAB
// ======= H√ÄM KI·ªÇM TRA TR·∫†NG TH√ÅI QR - ƒê√É S·ª¨A X·ª¨ L√ù TIMESTAMP =======
function checkQRStatus(qrcode) {
    const statusEl = document.getElementById("qrStatus");
    const sourceEl = document.getElementById("qrSource");
    
    if (!qrcode) {
        statusEl.textContent = "";
        if (sourceEl) sourceEl.textContent = "";
        return;
    }

    const code = qrcode.trim().toUpperCase();
    console.log("üîç ƒêang ki·ªÉm tra QR:", code);

    // H√ÄM CHUY·ªÇN ƒê·ªîI TIMESTAMP CH√çNH X√ÅC
    const parseDateTime = (dateValue, timeValue) => {
        console.log("üìÖ Raw timestamp - Date:", dateValue, "Time:", timeValue);

        let finalDate = new Date();

        // X·ª¨ L√ù TIMESTAMP C·ª¶A NG√ÄY
        if (dateValue) {
            try {
                if (typeof dateValue === 'string' && dateValue.includes('T')) {
                    const date = new Date(dateValue);
                    if (!isNaN(date.getTime())) {
                        finalDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                        console.log("‚úÖ ƒê√£ parse ng√†y t·ª´ timestamp:", finalDate.toLocaleDateString("vi-VN"));
                    }
                }
            } catch (e) {
                console.error("L·ªói parse timestamp ng√†y:", e);
            }
        }

        // X·ª¨ L√ù TIMESTAMP C·ª¶A GI·ªú - QUAN TR·ªåNG!
        if (timeValue) {
            try {
                if (typeof timeValue === 'string' && timeValue.includes('T')) {
                    const timeDate = new Date(timeValue);
                    if (!isNaN(timeDate.getTime())) {
                        // L·∫•y gi·ªù, ph√∫t, gi√¢y t·ª´ timestamp c·ªßa gi·ªù
                        const hours = timeDate.getHours();
                        const minutes = timeDate.getMinutes();
                        const seconds = timeDate.getSeconds();
                        
                        finalDate.setHours(hours, minutes, seconds);
                        console.log("‚úÖ ƒê√£ set gi·ªù t·ª´ timestamp:", hours + ":" + minutes + ":" + seconds);
                    }
                } else if (typeof timeValue === 'string') {
                    // N·∫øu l√† chu·ªói gi·ªù b√¨nh th∆∞·ªùng (HH:mm:ss)
                    const timeMatch = timeValue.match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})$/);
                    if (timeMatch) {
                        const hours = parseInt(timeMatch[1]);
                        const minutes = parseInt(timeMatch[2]);
                        const seconds = parseInt(timeMatch[3]);
                        finalDate.setHours(hours, minutes, seconds);
                        console.log("‚úÖ ƒê√£ set gi·ªù t·ª´ chu·ªói:", hours + ":" + minutes + ":" + seconds);
                    }
                }
            } catch (e) {
                console.error("L·ªói parse timestamp gi·ªù:", e);
            }
        }

        console.log("‚úÖ K·∫øt qu·∫£ datetime cu·ªëi c√πng:", finalDate.toLocaleString("vi-VN"));
        return finalDate;
    };

    // T√åM T·∫§T C·∫¢ B·∫¢N GHI C·ª¶A QR CODE N√ÄY
    const allRecords = [];
    
    // H√†m t√¨m ki·∫øm trong dataset
    const searchInDataset = (dataset, sourceName) => {
        dataset.forEach(record => {
            try {
                const recordQR = (
                    record["QR Code"] || 
                    record["QR code"] || 
                    record.qrCode || 
                    record.qr || 
                    ""
                ).toString().trim().toUpperCase();
                
                if (recordQR === code) {
                    // L·∫•y timestamp t·ª´ c√°c c·ªôt
                    const rawDate = record["Ng√†y"] || record.ngay || record.Date || record.date;
                    const rawTime = record["Gi·ªù"] || record.gio || record.Time || record.time;
                    
                    console.log(`üîç ${sourceName} - Timestamp:`, {
                        date: rawDate,
                        time: rawTime,
                        fullRecord: record
                    });
                    
                    const datetime = parseDateTime(rawDate, rawTime);
                    
                    if (datetime) {
                        allRecords.push({
                            source: sourceName,
                            result: (record["Ph√°n ƒë·ªãnh"] || record["K·∫øt qu·∫£"] || record.phanDinh || "").toString().trim().toUpperCase(),
                            datetime: datetime,
                            rawDate: rawDate,
                            rawTime: rawTime,
                            fullRecord: record
                        });
                    }
                }
            } catch (e) {
                console.error(`L·ªói x·ª≠ l√Ω record trong ${sourceName}:`, e);
            }
        });
    };

    // T√¨m trong c·∫£ 3 datasets
    console.log("üîç B·∫Øt ƒë·∫ßu t√¨m ki·∫øm...");
    searchInDataset(proData, "PRO");
    searchInDataset(sauTestData, "PQC");
    searchInDataset(qcData, "QC");

    console.log("üìä T·ªïng s·ªë b·∫£n ghi t√¨m th·∫•y:", allRecords.length, allRecords);

    // S·∫ÆP X·∫æP THEO TH·ªúI GIAN M·ªöI NH·∫§T
    allRecords.sort((a, b) => b.datetime.getTime() - a.datetime.getTime());
    
    // L·∫§Y B·∫¢N GHI G·∫¶N NH·∫§T
    const latestRecord = allRecords[0];

    if (!latestRecord) {
        statusEl.textContent = "üÜï CH∆ØA TEST";
        statusEl.style.color = "red";
        if (sourceEl) sourceEl.textContent = "";
        return;
    }

    console.log("üèÜ B·∫£n ghi g·∫ßn nh·∫•t:", latestRecord);

    // HI·ªÇN TH·ªä K·∫æT QU·∫¢
    let statusText = "";
    let statusColor = "black";

    if (latestRecord.result === "OK") {
        statusColor = "green";
        switch(latestRecord.source) {
            case "PRO": statusText = "‚úÖ ƒê√É PASS TEST"; break;
            case "PQC": statusText = "üîß PQC PASS"; break;
            case "QC": statusText = "üìë QC PASS"; break;
        }
    } else if (latestRecord.result === "NG") {
        statusColor = "red";
        switch(latestRecord.source) {
            case "PRO": statusText = "‚ùå TEST FAIL"; break;
            case "PQC": statusText = "üîß PQC FAIL"; break;
            case "QC": statusText = "üìë QC FAIL"; break;
        }

        // KI·ªÇM TRA RE-TEST
        const hasRetest = allRecords.some(record => 
            record.result === "OK" && record.datetime > latestRecord.datetime
        );

        if (hasRetest) {
            statusText += " ‚Üí ƒê√É RE-TEST";
            statusColor = "blue";
        } else {
            statusText += " ‚Üí CH∆ØA RE-TEST";
        }
    } else {
        statusText = "‚ùì KH√îNG X√ÅC ƒê·ªäNH";
        statusColor = "orange";
    }

    statusEl.textContent = statusText;
    statusEl.style.color = statusColor;

    // HI·ªÇN TH·ªä TH√îNG TIN NGU·ªíN V√Ä TH·ªúI GIAN CH√çNH X√ÅC
    if (sourceEl) {
        const displayTime = latestRecord.datetime.toLocaleString("vi-VN", {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
        
        sourceEl.textContent = `${latestRecord.source}: ${displayTime}`;
        
        // Debug th√¥ng tin timestamp
        console.log("üîç DEBUG TIMESTAMP:", {
            source: latestRecord.source,
            rawDate: latestRecord.rawDate,
            rawTime: latestRecord.rawTime,
            parsedDate: latestRecord.datetime.toLocaleDateString("vi-VN"),
            parsedTime: latestRecord.datetime.toLocaleTimeString("vi-VN"),
            finalDisplay: displayTime
        });
    }
}
    // ===================== REPORT & CHARTS (main sheet) =====================
    let paretoChart, dailyChart;
    let clusterize = null;
    let filteredDataGlobal = [];

    function populateFilters(data){
      const maSPs = new Set();
      const pos = new Set();
      data.forEach(r=>{
        if (r.maHang) maSPs.add(r.maHang);
        if (r.po) pos.add(r.po);
      });
      fillSelect("maSP",maSPs);
      fillSelect("po",pos);
    }

    function fillSelect(id, values){
      const select = document.getElementById(id);
      select.innerHTML = `<option value="">T·∫•t c·∫£</option>`;
      values.forEach(v=>select.innerHTML+=`<option value="${v}">${v}</option>`);
    }

    function applyFilters() {
  window.isFiltered = true;
  window.preventAutoReload = true;
  
  const searchQR = document.getElementById("searchQR").value.trim().toUpperCase();
  const fromDate = document.getElementById("fromDate").value;
  const toDate = document.getElementById("toDate").value;
  const maSP = document.getElementById("maSP").value;
  const po = document.getElementById("po").value;

  console.log("üîç Filtering - From:", fromDate, "To:", toDate);

  filteredDataGlobal = qcData.filter(r => {
    let match = true;

    const qrValue = r["QR Code"] || r["Qr code"] || r["QR code"] || r.qrCode || r.qr || "";
    const maHangValue = r["M√£ h√†ng"] || r.maHang || "";
    const poValue = r["PO"] || r.po || "";
    const ngayStr = r["Ng√†y"] || r.ngay;
    const ngay = parseDateImproved(ngayStr); // Chuy·ªÉn ng√†y t·ª´ chu·ªói sang ƒë·ªëi t∆∞·ª£ng Date

    // L·ªçc theo QR
    if (searchQR && !qrValue.toString().toUpperCase().includes(searchQR)) match = false;

    // L·ªçc theo m√£ s·∫£n ph·∫©m
    if (maSP && maHangValue !== maSP) match = false;

    // L·ªçc theo PO
    if (po && poValue !== po) match = false;

    // --- L·ªçc theo kho·∫£ng ng√†y (bao g·ªìm c·∫£ ng√†y ƒë·∫ßu & ng√†y cu·ªëi) ---
    let filterFrom = null, filterTo = null;
    if (fromDate) {
      filterFrom = new Date(fromDate);
      filterFrom.setHours(0, 0, 0, 0);
    }
    if (toDate) {
      filterTo = new Date(toDate);
      filterTo.setHours(0, 0, 0, 0);
    }

    if ((filterFrom || filterTo) && !ngay) {
      // N·∫øu b·∫£n ghi kh√¥ng c√≥ ng√†y m√† ng∆∞·ªùi d√πng ch·ªçn kho·∫£ng th·ªùi gian -> lo·∫°i
      match = false;
    } else if (ngay) {
      // Chu·∫©n h√≥a ng√†y b·∫£n ghi (ch·ªâ l·∫•y ph·∫ßn ng√†y)
      const ngayOnly = new Date(ngay.getFullYear(), ngay.getMonth(), ngay.getDate());

      // Bao g·ªìm c·∫£ ng√†y ƒë·∫ßu ti√™n v√† ng√†y cu·ªëi c√πng
      if (filterFrom && ngayOnly < filterFrom) match = false;
      if (filterTo && ngayOnly > filterTo) match = false;
    }

    return match;
  });

  console.log("‚úÖ Filtered data count:", filteredDataGlobal.length);

  // Hi·ªÉn th·ªã d·ªØ li·ªáu sau khi l·ªçc
  renderReportTable(filteredDataGlobal);
  
  // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng b·∫£n ghi hi·ªÉn th·ªã
  const recordCount = document.getElementById("recordCount");
  if (recordCount) {
    const totalCount = qcData.length;
    const filteredCount = filteredDataGlobal.length;
    if (filteredCount < totalCount) {
      recordCount.innerHTML = `ƒêang hi·ªÉn th·ªã: <b>${filteredCount}</b> / <b>${totalCount}</b> d√≤ng (ƒë√£ l·ªçc)`;
    } else {
      recordCount.textContent = `T·ªïng: ${totalCount} d√≤ng`;
    }
  }

  // C·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì v·ªõi d·ªØ li·ªáu l·ªçc
  drawPareto(filteredDataGlobal);
  drawDailyChart(filteredDataGlobal);
}

    function resetFilters() {
      document.getElementById("searchQR").value = "";
      document.getElementById("fromDate").value = "";
      document.getElementById("toDate").value = "";
      document.getElementById("maSP").value = "";
      document.getElementById("po").value = "";
      
      window.isFiltered = false;
      renderReportTable(qcData);
      
      const recordCount = document.getElementById("recordCount");
      if (recordCount) {
        recordCount.textContent = `T·ªïng: ${qcData.length} d√≤ng`;
      }
      
      // V·∫Ω l·∫°i bi·ªÉu ƒë·ªì v·ªõi to√†n b·ªô d·ªØ li·ªáu
      drawPareto(qcData);
      drawDailyChart(qcData);
    }

    function renderReportTable(data) {
      const rows = data.map(r => {
        let gioRaw = r["Gi·ªù"] || r.gio || "";
        let ngayRaw = r["Ng√†y"] || r.ngay || "";

        function formatDateTime(value, type="date") {
          if (!value) return "";
          try {
            const d = new Date(value);
            if (isNaN(d)) return value;
            if (type === "time") return d.toLocaleTimeString("vi-VN", { hour12: false });
            return d.toLocaleDateString("vi-VN");
          } catch {
            return value;
          }
        }

        const gio = formatDateTime(gioRaw, "time");
        const ngay = formatDateTime(ngayRaw, "date");

        return `
          <tr>
            <td>${r["M√£ h√†ng"] || r.maHang || ""}</td>
            <td>${r["QR code"] || r.qrCode || ""}</td>
            <td>${r["Ph√°n ƒë·ªãnh"] || r.phanDinh || ""}</td>
            <td>${r["M√¥ t·∫£ l·ªói"] || r.moTaLoi || ""}</td>
            <td>${gio}</td>
            <td>${ngay}</td>
            <td>${r["S·ªë l·∫ßn xu·∫•t hi·ªán"] || r.soLan || ""}</td>
            <td>${r["M√£ Nh√¢n Vi√™n"] || r.maNV || r.User || ""}</td>
            <td>${r["Ca l√†m vi·ªác"] || r.caLam || r.Shift || ""}</td>
            <td>${r["PO"] || r.po || ""}</td>
            <td>${r["Ghi ch√∫"] || r.ghichu || ""}</td>
          </tr>
        `;
      });

      if (!clusterize) {
        clusterize = new Clusterize({
          rows: rows,
          scrollId: 'scrollArea',
          contentId: 'clusterize-content'
        });
      } else {
        clusterize.update(rows);
      }

      const info = document.getElementById("recordCount");
      if (info) info.textContent = `T·ªïng: ${data.length} d√≤ng`;
    }

    function drawPareto(data){
      const canvas = document.getElementById("paretoChart");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (paretoChart) try{ paretoChart.destroy(); }catch(e){}
      const loiCount = {};
      data.forEach(r=>{
        if (r.moTaLoi && r.phanDinh === "NG") {
          loiCount[r.moTaLoi] = (loiCount[r.moTaLoi] || 0) + 1;
        }
      });
      const loiSorted = Object.entries(loiCount).sort((a,b)=>b[1]-a[1]);
      const labels = loiSorted.map(x=>x[0]);
      const values = loiSorted.map(x=>x[1]);
      const total = values.reduce((a,b)=>a+b,0) || 1;
      const cumsum = values.map((sum=>v=>sum+=v)(0));
      const cumPerc = cumsum.map(s=>(s/total*100).toFixed(1));
      paretoChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [{
            label: "S·ªë l·ªói",
            data: values,
            backgroundColor: "#3498db",
            order: 2
          },{
            label: "T·ª∑ l·ªá t√≠ch l≈©y (%)",
            data: cumPerc,
            type: "line",
            borderColor: "#e74c3c",
            backgroundColor: "rgba(231,76,60,0.1)",
            fill: true,
            yAxisID: "y1",
            order: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { beginAtZero: true, title: { display: true, text: "S·ªë l·ªói" } },
            y1: { position: "right", beginAtZero: true, max: 100, title: { display: true, text: "T·ª∑ l·ªá %" }, grid: { drawOnChartArea: false } }
          }
        }
      });
    }

    function drawDailyChart(data) {
    const canvas = document.getElementById("dailyChart");
    if (!canvas) return;
    
    const ctx = canvas.getContext("2d");
    if (dailyChart) {
        try { dailyChart.destroy(); } catch(e) {}
    }

    console.log("üîÑ V·∫Ω bi·ªÉu ƒë·ªì v·ªõi", data.length, "b·∫£n ghi");

    // C√ÅCH TI·∫æP C·∫¨N M·ªöI: X·ª¨ L√ù TR·ª∞C TI·∫æP KH√îNG QUA H√ÄM PH·ª§
    const dateStats = {};
    
    // 1. THU TH·∫¨P V√Ä PH√ÇN T√çCH D·ªÆ LI·ªÜU TR·ª∞C TI·∫æP
    data.forEach((record, index) => {
        const rawDate = record["Ng√†y"] || record.ngay;
        const result = (record["Ph√°n ƒë·ªãnh"] || record.phanDinh || "").toString().trim().toUpperCase();
        
        if (!rawDate) {
            console.warn(`B·∫£n ghi ${index} kh√¥ng c√≥ ng√†y`);
            return;
        }

        // X·ª¨ L√ù NG√ÄY TR·ª∞C TI·∫æP - KH√îNG D√ôNG H√ÄM parseDateImproved
        let dateObj = null;
        let dateKey = null;
        let displayDate = null;

        // Th·ª≠ c√°c ƒë·ªãnh d·∫°ng ph·ªï bi·∫øn
        if (rawDate.includes('/')) {
            const parts = rawDate.split('/');
            if (parts.length === 3) {
                const day = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1;
                const year = parseInt(parts[2]);
                dateObj = new Date(year, month, day);
                dateKey = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                displayDate = `${String(day).padStart(2, '0')}/${String(month + 1).padStart(2, '0')}/${year}`;
            }
        } else if (rawDate.includes('-')) {
            const parts = rawDate.split('-');
            if (parts.length === 3) {
                if (parts[0].length === 4) {
                    // yyyy-mm-dd
                    dateObj = new Date(parts[0], parts[1] - 1, parts[2]);
                    dateKey = rawDate;
                    displayDate = `${parts[2]}/${parts[1]}/${parts[0]}`;
                } else {
                    // dd-mm-yyyy
                    dateObj = new Date(parts[2], parts[1] - 1, parts[0]);
                    dateKey = `${parts[2]}-${parts[1]}-${parts[0]}`;
                    displayDate = `${parts[0]}/${parts[1]}/${parts[2]}`;
                }
            }
        }

        // Fallback: parse tr·ª±c ti·∫øp
        if (!dateObj || isNaN(dateObj.getTime())) {
            dateObj = new Date(rawDate);
            if (!isNaN(dateObj.getTime())) {
                dateKey = dateObj.toISOString().split('T')[0];
                displayDate = `${String(dateObj.getDate()).padStart(2, '0')}/${String(dateObj.getMonth() + 1).padStart(2, '0')}/${dateObj.getFullYear()}`;
            }
        }

        if (!dateObj || isNaN(dateObj.getTime())) {
            console.warn(`Kh√¥ng th·ªÉ parse ng√†y: "${rawDate}"`);
            return;
        }

        // S·ª¨ D·ª§NG DATEKEY L√ÄM KEY CH√çNH
        if (!dateStats[dateKey]) {
            dateStats[dateKey] = {
                displayDate: displayDate,
                ok: 0,
                ng: 0,
                total: 0,
                dateObj: dateObj,
                rawDate: rawDate // L∆∞u c·∫£ ng√†y g·ªëc ƒë·ªÉ debug
            };
        }

        const stats = dateStats[dateKey];
        if (result === "OK") {
            stats.ok++;
        } else if (result === "NG") {
            stats.ng++;
        }
        stats.total = stats.ok + stats.ng;

        console.log(`‚úÖ ${rawDate} -> ${dateKey} (${displayDate}): ${result}`);
    });

    console.log("üìä Th·ªëng k√™ theo ng√†y:", dateStats);

    // 2. T·∫†O M·∫¢NG NG√ÄY ƒê·∫¶Y ƒê·ª¶
    const allDateKeys = Object.keys(dateStats);
    if (allDateKeys.length === 0) {
        console.warn("‚ùå Kh√¥ng c√≥ ng√†y n√†o h·ª£p l·ªá");
        return;
    }

    // S·∫ÆP X·∫æP NG√ÄY
    allDateKeys.sort();
    console.log("üìÖ T·∫•t c·∫£ ng√†y (ƒë√£ s·∫Øp x·∫øp):", allDateKeys);

    // 3. CHU·∫®N B·ªä D·ªÆ LI·ªÜU CHO BI·ªÇU ƒê·ªí
    const labels = [];
    const okData = [];
    const ngData = [];
    const totalData = [];
    const percNG = [];

    allDateKeys.forEach(dateKey => {
        const stats = dateStats[dateKey];
        
        labels.push(stats.displayDate);
        okData.push(stats.ok);
        ngData.push(stats.ng);
        totalData.push(stats.total);
        
        const percentage = stats.total > 0 ? (stats.ng / stats.total * 100) : 0;
        percNG.push(parseFloat(percentage.toFixed(2)));
        
        console.log(`üìà ${stats.displayDate}: OK=${stats.ok}, NG=${stats.ng}, Total=${stats.total}, %NG=${percentage.toFixed(2)}%`);
    });

    // 4. KI·ªÇM TRA XEM C√ì THI·∫æU NG√ÄY KH√îNG
    console.log("üîç KI·ªÇM TRA CU·ªêI C√ôNG:");
    console.log("S·ªë ng√†y trong d·ªØ li·ªáu:", allDateKeys.length);
    console.log("S·ªë ng√†y trong bi·ªÉu ƒë·ªì:", labels.length);
    console.log("Ng√†y trong bi·ªÉu ƒë·ªì:", labels);

    // 5. V·∫º BI·ªÇU ƒê·ªí
    try {
        dailyChart = new Chart(ctx, {
            type: "bar",
            data: {
                labels: labels,
                datasets: [
                    { 
                        label: "T·ªïng s·ªë l∆∞·ª£ng", 
                        data: totalData, 
                        backgroundColor: "#2ecc71", 
                        yAxisID: "y",
                        barPercentage: 0.6
                    },
                                        { 
                        label: "NG", 
                        data: ngData, 
                        backgroundColor: "#e74c3c", 
                        yAxisID: "y",
                        barPercentage: 0.6
                    },
                    { 
                        label: "% NG/T·ªïng", 
                        data: percNG, 
                        type: "line", 
                        borderColor: "#2980b9", 
                        backgroundColor: "rgba(41, 128, 185, 0.1)", 
                        yAxisID: "y1", 
                        tension: 0.4,
                        borderWidth: 3,
                        pointBackgroundColor: "#2980b9",
                        pointBorderColor: "#ffffff",
                        pointBorderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: {
                    y: { 
                        beginAtZero: true, 
                        title: { display: true, text: "S·ªë l∆∞·ª£ng" }
                    },
                    y1: { 
                        position: "right", 
                        beginAtZero: true, 
                        max: 100, 
                        title: { display: true, text: "% NG" }, 
                        grid: { drawOnChartArea: false } 
                    },
                    x: {
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) label += ': ';
                                if (context.dataset.label === '% NG/T·ªïng') {
                                    label += context.parsed.y + '%';
                                } else {
                                    label += context.parsed.y;
                                }
                                return label;
                            }
                        }
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    }
                }
            }
        });
        
        console.log("‚úÖ Bi·ªÉu ƒë·ªì ƒë√£ v·∫Ω th√†nh c√¥ng v·ªõi", labels.length, "ng√†y");
    } catch (error) {
        console.error("‚ùå L·ªói v·∫Ω bi·ªÉu ƒë·ªì:", error);
    }
}

    // ===================== Window onload =====================
    window.onload = function() {
    loadReferenceData();      // T·∫£i d·ªØ li·ªáu PRO
    loadSauTestData();        // T·∫£i d·ªØ li·ªáu PQC
    reloadFromGoogle();       // T·∫£i d·ªØ li·ªáu QC
    showTab(1);
  
    // Hi·ªÉn th·ªã gi·ªõi h·∫°n QR code ban ƒë·∫ßu
    const initialMahang = document.getElementById("mahang").value;
    if (initialMahang) {
    showQRLimitInfo(initialMahang);
     }
    };

    // Auto refresh c·∫£ 3 datasets
    setInterval(() => {
      console.log("üîÅ Auto refresh c·∫£ PRO, PQC v√† QC data...");
      loadReferenceData(true);
      loadSauTestData(true);
      reloadFromGoogle();
    }, 1 * 60 * 1000); // 1 ph√∫t

    // H√†m hi·ªÉn th·ªã th√¥ng b√°o t·∫°m th·ªùi
    function showTempNotification(message, duration = 3000) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #27ae60;
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        z-index: 10000;
        font-weight: bold;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      `;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, duration);
    }

    // ===================== END =====================
  </script>
</body>
</html>